#!/usr/bin/env python3
# Copyright (c) 2021, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# ==============================================================================
# o - a wrapper for OCI CLI to simplify and edify
#
# Author: Kevin.Colwell@oracle.com
# ==============================================================================

import signal
import time
import textwrap
import subprocess
import re
import json
import getopt
import sys
import os
import fcntl
import errno
import datetime
VERSION = "1.2"
UPDATED = "2022-05-25"

# ==============================================================================
# Global variables
# ==============================================================================
ocids_file_name = ''     # name of file where OCIDs are saved
ocid = {}                # dict of known ocids
ocids = []               # list of known ocids
orphans = []             # orphaned ocids (with no compartment) found in ocids file
command = []             # commands with required and optional params
show_help = False        # user asked for help
go = False               # execute the oci cli command
nogo = False             # don't execute due to error in ocid substitutions
quiet = False            # quiet mode - don't show expanded command or headers
Quiet = False            # Quieter mode - don't show matching commands
region = ''              # region
region_code = ''         # 3-letter region code
ocids_in_output = False  # substitute names for ocids in output

# Universally useful fields as default output, if no "-o" on command line.
# This leverages the fact that fields not found in data are quietly ignored.
# We want to show the most interesting fields for the most common ocid types.
default_out_spec = 'name{:.30}#shape#cidr-block#prohibit-public{:5.5}' \
    '#lifec#gbs{:>5.5}#size#availability-domain{:.1}#fault-domain{:>1.1}' \
    '#resource-type' \
    '#created{:16.16}#compartment{:.20}#instance-id' \
    '#id{:>8.8}' \
    '#direction#destination' \
    '#ip-address#public-ip#private-ip' \
    '#vnic-id#desc{:.40}' \
    '#access-uri#storage-tier'

matches = []                   # list of commands that match user input
best_match = None              # matches[best_match] is the closest match
all_options_for_this_cmd = ''  # for best_match
remaining_options = ''         # for best_match
options_out = []               # list of expanded options to be passed to oci cli
oci_command_line = ''          # the complete oci cli command in string form
column = {}                    # field format info: format:'{:}', offset:0, maxwidth:n
use_bold = True                # enable xterm bold highlighting
wrap = 120                     # wrap at column <wrap>
global_options = ''

# ==============================================================================


def usage(s=''):
    print("""
    o - a friendly helper for Oracle Cloud Infrastructure CLI

    usage: o [<o options>] <oci-command> [<oci-options>] [go]

      <o options>
         -o name#life#time{:.16}  Table output
                            Show fields that match "name", "life" or "time"
                            Truncate "time" at 16 characters
         -o name,life,time  CSV output
         -o name/life/time  Text output - one field per line
         -o /               Show all fields in text
         -o json            JSON format - unfiltered oci output""")
    if s == "help":
        print("""
         -q            quiet mode - suppress headers, expanded oci command
                       Useful when sending results to pipe or redirect

         ocids "name"  Show saved OCIDs for resources matching "name"

         prune "name"  Remove saved OCIDs for resources matching "name",
                       or everything under compartment "name"

         help          This help.  Use "--help go" for oci help""")
    print("""
      <oci-command>    The oci "service resource action" specification
      <oci-options>    Options and parameters for <oci-command>
                       These will be expanded into a more correct oci command

      go               Run the oci command if the line ends with "go" (or ".")

    o Version {} - {}
    """.format(VERSION, UPDATED))
    if s not in ('', 'help'):
        print(bold(s) + '\n')
    exit(1)

# ==============================================================================


def interrupted(sig, frame):
    error_out("Interrupted")
    exit(1)

# ==============================================================================


def bold(s=''):
    return '\033[1m' + s + '\033[0m' if use_bold else s

# ==============================================================================


def error_out(msg):
    """Decode JSON ServiceError."""

    if msg.startswith('ServiceError:'):
        j = json.loads(msg[14:])
        print(bold('ServiceError(' + str(j['status']) + '): ' + str(j['code'])), file=sys.stderr)
        print(bold(j['message']), file=sys.stderr)
    else:
        print(bold(msg), file=sys.stderr)

# ==============================================================================


def read_oci_commands_file():
    """Read oci_commands for the list of all cli commands with parameters.
    First look for oci_commands where o is installed.
    If not found, look for ~/.oci/oci_commands
    If not found, create new file ~/.oci/oci_commands
    """

    global global_options
    pathname = os.path.dirname(sys.argv[0])
    if not pathname:
        pathname = '.'
    oci_commands_file = pathname + '/oci_commands'
    if not os.path.isfile(oci_commands_file):
        oci_commands_file = os.path.expanduser('~/.oci/oci_commands')

    command_list = []
    try:
        for line in open(oci_commands_file).read().splitlines():
            if re.match(r'oci ', line):
                command_list.append(parse_oci_command_options(line))
            elif re.match(r'global_options ', line):
                global_options = line[line.find(' ') + 1:]

    except FileNotFoundError:
        print(bold('No ' + oci_commands_file + ' file.'))
        print('Create it with:\n')
        print(bold('    o oci_commands'))
        print('\nIt takes about two minutes.')
        exit(1)
    except OSError as e:
        msg = "{0}".format(e)
        print(bold(msg))
        exit(1)
    if len(command_list) < 1000:
        print(bold('File ' + oci_commands_file + ' is incomplete.'))
        print('Re-create it with:')
        print(bold('    o oci_commands'))
        exit(1)
    return command_list

# ==============================================================================


def run_command(command):
    if os.system(command):
        if re.search('iam compartment get', command):
            return(1)
        print(bold("It looks like that didn't work.  So sorry."))
        exit(1)
    return 0

# ==============================================================================


def get_from_oci_config(key):
    """Look in config file for key = value"""

    s = oci_command_line
    if '--profile' in s:
        profile = s.split()[s.split().index('--profile') + 1]
    elif os.getenv('OCI_CLI_PROFILE'):
        profile = os.getenv('OCI_CLI_PROFILE')
    else:
        profile = 'DEFAULT'

    config_file = os.path.expanduser('~/.oci/config')
    if '--config' in oci_command_line:
        config_file = s.split()[s.split().index('--config') + 1]

    if not os.path.exists(config_file) and os.path.exists('/etc/oci/config'):
        config_file = '/etc/oci/config'

    try:
        value = None
        this_profile = ''
        with open(config_file, 'r') as f:
            for line in f:
                m = re.search(r'^\[(.+)\]', line)
                if m:
                    this_profile = m.group(1)

                if this_profile in ('DEFAULT', profile):
                    m = re.search(key, line)
                    if m:
                        value = line.split('=')[1].strip()
                        if this_profile == profile:
                            return value
        return value

    except BaseException:
        return None

# ==============================================================================


def setup_ocids_file():
    """Create or update ocids_file for tenancy found on command line.
    If run with "o <tenancy-ocid>" run three o commands to populate ocids
        o <tenancy-ocid>
    Otherwise offer help and then exit.
    On completion exit; do not return from this function.
    """

    if not (len(sys.argv) in [2, 3] and re.search(
            'ocid1.tenancy.{50}', sys.argv[1])):
        # No ocid provide; offer help
        print(bold('No ' + ocids_file_name + ' found.\n'))
        print("""To setup "o" just run:
  \033[1mo <your-tenancy-ocid> \033[0m

and I'll do this for you:

  o iam compartment get -c <tenancy-ocid> go
  o iam ad list -c <tenancy-ocid> go
  o iam region list go
  o iam compartment list -c <tenancy-ocid> -ciis true -all go
        """)

        # To be extra helpful, get likely tenancy ocid from oci config file

        oci_config_file = os.path.expanduser('~/.oci/config')
        if not os.path.exists(oci_config_file) \
                and os.path.exists('/etc/oci/config'):
            oci_config_file = '/etc/oci/config'

        t = get_from_oci_config('tenancy')
        print('Try:\n', bold('  o ' + t))

    else:
        # <tenancy-ocid> provided... Let's roll!
        print("Tenancy ocid:", sys.argv[1])
        if len(sys.argv) == 3:
            print("Tenancy name:", sys.argv[2])
        print(bold('Setting up your ' + ocids_file_name + ' file:'))
        if run_command(sys.argv[0] + ' -o name iam compartment get -c ' + sys.argv[1] + ' go'):
            # compartment get on tenancy failed; try saving a stub for tenancy
            print("\nThat didn't work.  Creating a stub for tenancy root.")
            newids = {'root': {
                      'type': 'tenancy',
                      'alias': 'root' if len(sys.argv) == 2
                               else sys.argv[2],
                      'id': sys.argv[1],
                      'name': 'root' if len(sys.argv) == 2 else sys.argv[2]
                      },
                      }
            ocids_file('write', newids)
            exit(0)
        run_command(sys.argv[0] + ' -o name iam ad list -c ' + sys.argv[1] + ' go')
        run_command(sys.argv[0] + ' -o name iam region list go')
        run_command(sys.argv[0] + ' -o name iam compartment list -c '
                    + sys.argv[1] + ' -ciis true -all go')
        print('\n' + bold('All set. Have fun!\n'))

    exit(0)

# ==============================================================================


def ocids_file(action, new_ocids={}):
    """Take action on ocids_file_name:
    action=read - populate globals:
        ocid - dict of resources
        ocids - list of resources
    action=write - write ocids file
       If new_ocids = {}, write ocids to file (used by prune to remove entries)
       if new_ocids, merge new entries into file:
         - lock ocids file, then
         - read ocids file to get latest updates
         - merge new_ocids with ocids
         - rewrite file and unlock
    """
    global ocid, ocids, ocids_file_name

    if os.path.exists('.ocids'):
        ocids_file_name = '.ocids'
    elif os.path.exists('ocids'):
        ocids_file_name = 'ocids'
    else:
        ocids_file_name = os.path.expanduser('~/.oci/ocids')

    # Run setup if no ocids_file exists or
    # if this is an "o <tenancy>" setup command and new_ocids is empty
    if (not new_ocids
            and (not re.search('get.*-c ocid..tenancy', ' '.join(sys.argv))
                 and (not os.path.exists(ocids_file_name)
                 or re.search('o [^c]*ocid..tenancy', ' '.join(sys.argv))))):
        setup_ocids_file()

    if action == 'read' and not os.path.exists(ocids_file_name):
        return

    tries = 1
    while tries <= 10:
        try:
            if os.path.exists(ocids_file_name):
                os.umask(0o077)
                f = open(ocids_file_name, 'r+')
                if new_ocids:
                    fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
                if new_ocids or action == 'read':
                    ocids = json.load(f)
                    # Convert list of ocids into dict of ocids. Use id as key.
                    ocid = {i['id']: i for i in ocids if 'availabilitydomain' != i['type']}
                    ocid.update({i['name']: i for i in ocids if 'availabilitydomain' == i['type']})
            else:
                os.umask(0o077)
                f = open(ocids_file_name, 'w+')

            if action == 'write':
                # merge
                ocid.update(new_ocids)
                # Don't save ocids for deleted resources
                ocid = {k: v for (k, v) in ocid.items()
                        if 'lifecycle-state' not in v
                        or v['lifecycle-state'] not in ('DELETED', 'TERMINATED')
                        and k not in orphans}
                # clean up temp values in ocid
                for k, v in ocid.items():
                    if 'score' in v:
                        del v['score']
                    if 'parents' in v:
                        del v['parents']

                # convert dict to list
                ocids = [ocid[k] for k in ocid.keys()]
                ocids.sort(key=lambda x:
                           (x['type'], x['alias'].lower(), x['id']))
                # write ocids list to ocid_file
                f.seek(0)
                print(json.dumps(ocids, indent=4), file=f)
                f.truncate()
            f.close()
            return

        except IOError as e:
            if e.errno != errno.EAGAIN:
                print(bold(ocids_file_name + ': not accessible'), file=sys.stderr)
            f.close()
            time.sleep(0.05 * 2**tries)
            tries += 1
        except ValueError:
            # Try again
            print(bold(ocids_file_name + ': JSON error on read - retry #' + str(tries)),
                  file=sys.stderr)
            f.close()
            time.sleep(0.05 * tries)
            tries += 1

    if tries >= 10:
        print(bold(ocids_file_name + ':  ' + action + ' failed'), file=sys.stderr)

    return

# ==============================================================================


def get_new_ocids_from_returned_items(items):
    """Collect ocids found in results from oci cli.
    For consistency each entry must have: type, alias, id.
    In addition to those, we collect anything that might be used by omap.
    """

    # special case for region list - save the whole list in one entry
    if 'oci iam region list' in oci_command_line:
        return {'regionlist': {
                'type': 'regionlist',
                'alias': 'regionlist',
                'id': 'regionlist',
                'data': items}}

    if oci_command_line.startswith('oci search'):
        for i in items:
            if 'identifier' in i and 'id' not in i:
                i['id'] = i['identifier']

    if not items or 'id' not in items[0]:
        return {}

    collected = {}
    try:
        for item in items:
            type = item['id'].split('.')[1] if '.' in item['id'] else ''
            # Special case: save AD-name:n because commands use name, not ocid
            ID = item['id']
            if 'availability' in item['id']:
                ID = item['name']
            if 'retention-rule' in oci_command_line:
                type = 'retentionrule'

            # Still need to validate with many OCID types:
            #    cpe, cross-connect, fast-connect, ip-sec, local-peering, nsg,
            #    virtual-circuit, par
            if type == 'availabilitydomain':
                alias = item['name'][-1:]
            elif 'object-name' in item:
                alias = item['name']
                type = "par"
            elif (type == 'routetable'
                  and item['display-name'].startswith('Default Route Table for ')):
                alias = item['display-name'][len('Default Route Table for '):]
            elif (type == 'securitylist'
                  and item['display-name'].startswith('Default Security List for ')):
                alias = item['display-name'][len('Default Security List for '):]
            elif type == 'vnicattachment':
                if item['instance-id'] in ocid:
                    alias = ocid[item['instance-id']]['alias']
                else:
                    alias = item['instance-id'][-8:]
                alias = '-'.join([alias, str(item['nic-index']), 'vlan' + str(item['vlan-tag'])])
            elif type == 'providerservice':
                alias = str(item['provider-name']) + ' ' + str(item['provider-service-name'])
            elif 'instanceconsoleconnection' in type:
                alias = ocid[item['instance-id']]['alias']
            elif 'name' in item:
                alias = item['name']
            elif 'display-name' in item:
                alias = item['display-name']
            elif 'db-name' in type:
                alias = item['db-name']
            else:
                # Unable to determine data type, don't add to collection
                return({})

            if not alias:
                alias = 'unnamed-' + type
            collected[ID] = {'type': type, 'alias': alias, 'id': item['id']}

            # Now add various non-empty fields depending on item type
            collected[ID].update({k: item[k] for k in item.keys() if (
                item[k] and (
                    k.endswith('-id')
                    or k.endswith('-tags')
                    or k.endswith('name')
                    or k.startswith('size')
                    or k in ['lifecycle-state',
                             'availability-domain',
                             'storage-tier',
                             'description',
                             'shape',
                             'cidr-block',
                             'dns-label',
                             'virtual-router-ip',
                             'virtual-router-mac',
                             'security-list-ids',
                             'route-rules',
                             'ip-addresses',
                             'private-ip',
                             'public-ip',
                             'is-primary',
                             'subnet-ids',
                             'access-type',
                             'created-by',
                             'time-expires',
                             'access-uri']))})
            if 'created-by' in item and '/' in item['created-by']:
                collected[ID]['created-by'] = item['created-by'].split('/')[1]
            if 'time-created' in item:
                collected[ID]['time-created'] = item['time-created'][:19]
            # Retain access-uri.
            if type == 'par' and ID in ocid and 'access-uri' in ocid[ID]:
                collected[ID]['access-uri'] = ocid[ID]['access-uri']
    except BaseException:
        print(bold('Unable to collect ocids of type ' + type
              + '. Please provide this data with your problem report:\n')
              + json.dumps(item, indent=4), file=sys.stderr)

    return collected

# ==============================================================================


def show_command(c, full=False, prefix='oci '):
    print(prefix + c['action'])
    if full:
        print('    requires\t' + re.sub(r' -', r'\n\t\t-', c['required']))
        print('    optional\t' + re.sub(r' -', r'\n\t\t-', c['optional']))
        if show_help:
            print('    global\t' + re.sub(r'\n', r'\n                ',
                  textwrap.fill(global_options, width=60, break_on_hyphens=False)))

# ==============================================================================


def parse_oci_command_options(line):
    """Separate oci command from --required and + --optional options."""
    c = {'action': '', 'required': '', 'optional': '', 'line': line}
    if ' + ' in line:
        [line, c['optional']] = line.split(' + ', 1)
    if ' --' in line:
        [c['action'], r] = line[4:].split(' --', 1)
        c['required'] = '--' + r
    else:
        c['action'] = line[4:]
    return(c)

# ==============================================================================


def args_match_command(c, params):
    """Compare argv with command "c" to see how well they match."""
    action = ' ' + c['action'] + ' '
    for a in params:

        # accept plurals in place of singulars
        if (len(a) > 3 and a[-1] == 's' and a not in ['address', 'access', 'waas']):
            a = a[:-1]

        # stop searching at first -opt
        if (len(a) and a[0] == '-'):
            return (True)

        # Look for full-word match first
        if ' ' + a + ' ' in action:
            # Scratch out match
            action = re.sub(' ' + a + ' ', ' ', action, count=1)
            continue

        # look for word starting with arg
        if ' ' + a in action:
            # Scratch out this match
            action = re.sub(' ' + a + r'\S+', ' ', action, count=1)
            continue

        # look for rlc -> really-long-command
        multi_re = ' ' + r'\w+\-'.join(list(a)) + r'\S+'
        if re.search(multi_re, action):
            # Scratch out this match
            action = re.sub(multi_re, ' ', action)
            continue
        return (False)
    return (True)

# ==============================================================================


def option_parameter(arg):
    """Look for match in remaining_options
        - Allow - in place of --
        - Replace partial opt with full option name
        --rlon ==> --really-long-option-name
    """
    a = arg.lstrip('-')
    if not a:
        return arg
    # special case for -c
    if a in ['c', 'cid']:
        a = 'compartment-id'

    m = re.search('(--' + a + ') ', remaining_options)
    if (m):
        return m.group(1)
    m = re.search('(--' + a + '[a-z-]*) ', remaining_options)
    if (m):
        return m.group(1)

    # build a regex a[0] + a[1] + -a[1] + -a[2]... for -rlon
    multi_re = '-+' + r'\w+\-'.join(list(a[:-1]))
    # special case if it ends in 'id'
    if len(a) > 2 and a[-2:] == 'id':
        multi_re += 'd\\b'
    else:
        multi_re += r'\w+\-' + a[-1] + r'[\w-]+'
    m = re.search(multi_re, remaining_options)
    if m:
        return m.group(0)

    # Unable to expand; just go with what user provided
    return arg

# ==============================================================================


def alias_match_score(spec, name):
    """Does user spec match this item name?
    score reflects quality of match.
    """
    if spec == name:
        return 40 + len(spec)
    elif spec.lower() == name.lower():
        return 25 + len(spec)
    elif re.match(spec + ' ', name):
        return 25 + int(200 * len(spec) / len(name)) / 10.0
    elif re.match(spec, name):
        return 20 + int(200 * len(spec) / len(name)) / 10.0
    elif re.match(spec, name, flags=re.I):
        return 10 + int(200 * len(spec) / len(name)) / 10.0
    elif re.search(spec, name, flags=re.I):
        return 5 + int(200 * len(spec) / len(name)) / 10.0
    return 0

# ==============================================================================


def get_item_parents(i):
    """Return heirarchy of compartments containing this item in list"""
    if 'parents' in i:
        return i['parents']
    if 'compartment-id' not in i:
        return [i['alias']]
    if i['compartment-id'] in ['', 'publisherCompartment']:
        return [i['alias']]
    if i['compartment-id'] in ocid:
        if i['type'] == 'availabilitydomain':
            return get_item_parents(ocid[i['compartment-id']]) + [i['name']]
        else:
            return get_item_parents(ocid[i['compartment-id']]) + [i['alias']]
    else:
        # Tag this as orphan for later removal?
        orphans.append(i['id'])
        return [i['alias']]

# ==============================================================================


def alias_match(spec, item):
    """Does user spec match this item alias - and parent(s)?
    Return True if match; score reflects quality of match
    """
    item['score'] = 0
    item['parents'] = get_item_parents(item)
    specs = list(filter(None, spec.split('/')))

    item_path = list.copy(item['parents'])
    for s in reversed(specs):
        # more specs than path parts?
        if not item_path:
            return False
        while item_path:
            i = item_path.pop()
            score = alias_match_score(s, i)
            if score > 0:
                if item['score'] == 0:
                    item['score'] = 2 * score
                else:
                    item['score'] += score
                break  # from while, to next "s"
            else:
                # not an alias match, look for ocid match
                if len(specs) == 1:
                    if re.search(spec, item['id'], flags=re.I):
                        item['score'] = int(1000 * len(spec) / len(item['id'])) / 10.0
                        return True
                    return False
                # This item heirarchy did not match specs.
                # Give up if it's the first part of spec or end of item_path
                if item['score'] == 0 or not item_path:
                    return False
                # Otherwise deduct 20% from score as a penalty
                item['score'] = int(item['score'] * .8)

    if item['score'] > 0:
        return True
    return False

# ==============================================================================


def type_match(option, item_type):
    """Compare option with item for type match, return boolean.
    If parameter --<option>-id doesn't match ocid1.<item_type>.oc1...
    add it to the list of exceptions.
    """

    if (option == item_type
            or (option.startswith('compartment') and item_type == 'tenancy')
            or (option.startswith('tenant') and item_type == 'tenancy')
            or (option == 'ig' and item_type == 'internetgateway')
            or (option == 'rt' and item_type == 'routetable')
            or (option == 'nsg' and item_type == 'networksecuritygroup')
            or (option == 'stack' and item_type == 'ormstack')
            or (option == 'sourcebootvolume' and item_type == 'bootvolume')
            or (option == 'image' and item_type == 'containerimage')
            or (option == 'repository' and item_type == 'containerrepo')
            or (option == 'dhcp' and item_type == 'dhcpoptions')
            or (option == 'application' and item_type == 'fnapp')
            or (option == 'function' and item_type == 'fnfunc')
            or (option == 'asset' and item_type in ('volume', 'bootvolume', 'volumegroup'))
            or (option == 'sddc' and item_type == 'vmwaresddc')
            or (option == 'avail' and len(item_type) == 1)):
        return True
    return False

# ==============================================================================


def ambiguous_value(option, value, matches):
    """Multiple matches with same score.  Ambiguous."""
    if (option):
        print(option, end=' ', file=sys.stderr)
    print(bold(value), 'is ambiguous. Try one of these:',
          file=sys.stderr)
    for m in matches:
        if m['score'] > 2:
            print('  (score=' + str(m['score']) + ')', '  ' + bold(('/'.join(m['parents'])
                  if 'parents' in m else m['alias'])), ' ({:8})'.format(m['id'][-8:]))
    global nogo
    nogo = True

# ==============================================================================


def datetime_parameter(dt):
    """construct datetime values relative to now or today +/- offset:
       now - current datetime
       today - start (00:00) of current day
       +/-<n>(wdhms) add/subtract <n> week/day/hour/minute/second."""

    # if time only (no date), prepend today's date
    if re.match(r'\d\d:\d\d', dt):
        return datetime.datetime.utcnow().strftime('%Y-%m-%dT') + dt + 'Z'

    dts = dt
    # return time delta from now|today|yesterday
    m = re.search(r'(?P<day>now|today|yesterday) *(?P<delta>.*)', dt)
    if m and m.group('day'):
        if m.group(1) == 'now':
            time = datetime.datetime.utcnow()
        elif m.group(1) in ('today', 'yesterday'):
            time = datetime.datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
            if m.group(1) == 'yesterday':
                time = time - datetime.timedelta(hours=24)
        dts = time.strftime('%Y-%m-%dT%H:%M:%S') + 'Z'
    if m and m.group('delta'):
        deltas = {'s': 1, 'm': 60, 'h': 60*60, 'd': 60*60*24, 'w': 60*60*24*7}  # noqa: E226
        m2 = re.search(r'(?P<s>[@+-]{,1})(?P<v>[\d:Z]*)(?P<u>[smhdw]{0,1})', m.group('delta'))
        try:
            # optional time delta +/- <n> week/day/hour/minute/second
            value = int(m2.group('v')) * deltas[m2.group('u')]
            if m2.group('s') == '-':
                value = value * -1
            time = time + datetime.timedelta(seconds=value)
            dts = time.strftime('%Y-%m-%dT%H:%M:%S') + 'Z'
        except (ValueError, KeyError):
            dts = dts[:11] + m.group('delta')
            if m.group('delta')[0] in '@+':
                dts = dts[:11] + m.group('delta')[1:]
            if dts[-1] != 'Z':
                dts = dts + 'Z'

    if dts.endswith('00:00:00Z'):
        return dts[:10]
    if dts.endswith(':00Z'):
        return dts[:16] + 'Z'
    return dts

# ==============================================================================


def get_region():
    """Determine the region in this order of precedence:
        --region on cmd line
        OCI_CLI_REGION in env
        --profile on cmd line
        OCI_CLI_PROFILE in env
    Return key.lower,name  E.g.: "iad","us-ashburn-1"
    """

    if 'regionlist' not in ocid:
        return '', ''

    r = ''
    if '--region ' in oci_command_line:
        ocl = oci_command_line.split()
        r = ocl[ocl.index('--region') + 1]
    elif os.getenv('OCI_CLI_REGION'):
        r = os.getenv('OCI_CLI_REGION')

    # If region not set, get it from config file
    if not r:
        r = get_from_oci_config('region')
    if not r:
        return None, None

    rmatch = [i for i in ocid['regionlist']['data'] if r.upper() == i['key'] or r in i['name']]
    if rmatch:
        return rmatch[0]['key'].lower(), rmatch[0]['name']
    return None, None

# ==============================================================================


def region_match(id):
    """Does ocid region match profile region?"""
    region_from_id = (id + '....').split('.')[3]
    if not region_code \
            or region_from_id == '' \
            or region_from_id == region_code \
            or region_from_id == region:
        return True
    return False

# ==============================================================================


def get_matching_ocid(option, value):
    """Look for ocid of correct type that matches value.
    If result is unique, or a strong match, return the OCID.
    If ambiguous, display possible matches and return None.
    """

    global nogo
    if value.startswith('ocid') and len(value) > 60:
        return value
    if '-' not in option:
        opt_type = option
    else:
        opt_type = re.sub('-', '', re.sub('-ids{0,1}$', '', option))
        # ocid type doesn't exactly match --resource-id type
        if opt_type == 'job':
            opt_type = 'ormjob'
        if opt_type == 'node' and 'rover' in oci_command_line:
            opt_type = 'rovernode'

    matches = [item for k, item in ocid.items() if
               type_match(opt_type, item['type'])
               and region_match(item['id'])
               and alias_match(value, item)]
    if not matches:
        matches = [item for k, item in ocid.items() if
                   type_match(opt_type, item['type'])
                   and alias_match(value, item)]
        if matches:
            print(bold('\n' + value + ' found in '
                  + matches[0]['id'].split('.')[3].upper() + ' region,'
                  + ' but you are working in ' + region_code.upper()))
    matches = sorted(matches, key=lambda i: i['score'], reverse=True)

    if option == 'bucket' and '/' not in value:
        return value

    if not matches:
        if option != 'bucket':
            print(opt_type, bold(value), 'not found.', file=sys.stderr)
            nogo = True
        return value

    # Is this match unique, or is it strong relative to other matches?
    if len(matches) == 1 or matches[0]['score'] > 5 + matches[1]['score']:
        if matches[0]['type'] in ('availabilitydomain', 'bucket'):
            if 'name' in matches[0]:
                return matches[0]['name']
            if 'display-name' in matches[0]:
                return matches[0]['display-name']
        return matches[0]['id']

    ambiguous_value(option, value, matches)
    return value

# ==============================================================================


def value_parameter(option, value):
    """Assist with command line parameters.
    Especially provide name -> ocid substitutions for --*id options.
    """

    # Get the parameter from help: --option [param_type]
    param_type = ''
    m = re.search(option + r' \[([\w -\|]+?)\]', all_options_for_this_cmd)
    if m:
        param_type = m.group(1)

    # If option is an OCID, see if value matches any saved ocids
    if option.endswith('-id') or option == "--availability-domain":
        match = get_matching_ocid(option, value)
        return match

    # Match "bucket-name" with bucket IDs
    if option == '--bucket-name':
        match = get_matching_ocid('bucket', value)
        return match

    # Convert list of resource names into a JSON list [complex type]
    if option.endswith('-ids'):
        idlist = []
        for v in value.split(','):
            if not v:
                continue
            o = get_matching_ocid(option, v)
            idlist.append(v)
        return(repr(json.dumps(idlist)))

    # Assist with datetime parameters
    if param_type == 'datetime':
        return datetime_parameter(value)

    # Special help with log-search --search-query "search comp1 comp2 | ..."
    # Substitute compartment ocid for one or more values.
    if option == '--search-query':
        m = re.search(r'search ([^|]+)', value)
        if m:
            for v in m.group(1).split():
                o = get_matching_ocid('compartment', v)
                if o != v:
                    value = re.sub(v, '"' + o + '"', value)

    return value

# ==============================================================================


def shell_escape(value):
    """If param contains special characters, enclose in quotes or
    double-quotes, and escape inner double-quotes
    """

    if re.search(r'[ "\'?()<>{}]', value):
        if "'" not in value:
            value = "'" + value + "'"
        elif '"' not in value:
            value = '"' + value + '"'
        else:
            value = '"' + re.sub(r'"', r'\"', value) + '"'
    return value

# ==============================================================================


def get_fields_from(spec, keynames):
    """Return list of fields based on user specification.
    Field separator determines output formatting.
    """

    fields = []
    sep = '|'
    if ',' in spec:
        sep = ','   # csv out
    elif ' ' in spec:
        sep = ' '   # space separated columns
    elif '\t' in spec:
        sep = '\t'   # tab separated columns
    elif '#' in spec:
        sep = '#'   # aligned out columns
    elif '/' in spec:
        sep = '/'   # one field per line
    if not keynames:
        return fields, sep   # show all fields

    specs = spec.split(sep if sep != ' ' else None)

    if sep == r'#':
        sep = '|'
    if not specs[-1]:
        specs.pop(-1)  # remove empty spec

    for sf in specs:
        s, fmt = sf, '{}'
        if s == '.':
            s = ''
        m = re.search('(.*)({.*})', s)
        if m:
            s, fmt = m.group(1), m.group(2)
        if s in sorted(keynames):               # exact keyname match
            fields.append(s)
            column[s] = {'format': fmt, 'offset': 0, 'minwidth': len(s)}
        else:
            for k in sorted(keynames):
                if s in k and k not in fields:  # partial keyname match
                    fields.append(k)
                    column[k] = {'format': fmt, 'offset': 0, 'minwidth': len(s)}
    if len(fields) == 0:
        if user_out_spec != default_out_spec:
            print(bold("no matching output fields: " + spec), file=sys.stderr)
        return(get_fields_from("/", keynames))
    return fields, sep

# ==============================================================================


def set_column_widths(fields, item_list):
    global maxkeylen
    for k in fields:
        if ocids_in_output:
            maxwidth = max([len(str(f[k])) for f in item_list])
        else:
            maxwidth = 3
            for f in item_list:
                if k in f:
                    width = len(str(f[k]))
                    if k != 'id' and str(f[k]) in ocid:
                        width = len(ocid[f[k]]['alias'])
                    maxwidth = max([maxwidth, width])
        maxwidth = max([maxwidth, column[k]['minwidth']])
        column[k]['maxwidth'] = maxwidth

        # if {:.<prec>} with no width, set width to min(maxwidth, <prec>)
        m = re.search(r':[<^>]*\.(\d+)', column[k]['format'])
        if m:
            n = min(maxwidth, int(m.group(1)))
            s = column[k]['format'][0:column[k]['format'].index('.')]
            column[k]['format'] = s + str(n) + '.' + str(n) + '}'

        # if right-aligned and truncated, output right-most characters
        m = re.search(r'>.*\.(\d+)', column[k]['format'])
        if m:
            column[k]['offset'] = -1 * int(m.group(1))
        if column[k]['format'] == '{}' \
                and out_sep == '|' \
                and k is not fields[-1]:
            column[k]['format'] = '{:<' + str(maxwidth) + '.' + str(maxwidth) + '}'
    maxkeylen = max([len(str(k)) for k in fields])
    # keyfmt - with of longest field name, for raw text output
    column['keyfmt'] = '{:>' + str(maxkeylen) + '}'
    return

# ==============================================================================


def show_column_headers(out_fields, sep):
    if quiet:
        return
    if sep == '|':
        for k in out_fields:
            print(bold(column[k]['format'].format(k)), end=' ', file=sys.stderr)
        print('', file=sys.stderr)
    elif sep != '/':
        if sep == ',':
            print(bold(sep.join([repr(f) for f in out_fields])), file=sys.stderr)
        else:
            print(bold(sep.join(out_fields)), file=sys.stderr)

# ==============================================================================


def show_item(item, fields, sep):
    """Report result in user specified -o format."""

    out = []
    for field in fields:
        value = str(item[field]) if field in item else ''
        if field not in ('id', 'identifier') and value in ocid and not ocids_in_output:
            value = ocid[item[field]]['alias']
            out.append(column[field]['format'].format(value[column[field]['offset']:]))
        else:
            if column[field]['format'] == '{}' and sep != '|':
                if field in item:
                    out.append(re.sub(r'[{}\'"[\]]', '', json.dumps(item[field], indent=4)))
            else:
                out.append(column[field]['format'].format(re.sub(r'[{}\'[\]]', '', value)[
                           column[field]['offset']:]))

    # one field per line
    if sep == '/':
        indent = '   ' + ' ' * maxkeylen
        for k, value in zip(fields, out):
            # Wrap long lines
            if k == 'access-uri':
                print(column['keyfmt'].format(k), ' ', value)
            else:
                if '\n' in value:
                    value = re.sub(r'(,){0,1}\n', '\n' + ' ' * (maxkeylen - 1), value).strip()
                    print(column['keyfmt'].format(k), ' ', value)
                else:
                    print(column['keyfmt'].format(k), ' ',
                          textwrap.fill(value,
                                        subsequent_indent=indent,
                                        break_on_hyphens=True,
                                        break_long_words=True,
                                        width=wrap - maxkeylen - 3))
        if len(fields) > 1:
            print('')

    # fields on one line, csv
    elif sep == ',':
        print(sep.join([repr(i) for i in out]))

    # fields on one line, space separated
    elif sep in (' ', '\t'):
        print((sep.join([str(item[f]) for f in out_fields])).rstrip())

    # sep is '|' or '#', table output
    else:
        print(' '.join(out))

# ==============================================================================


def omap(argv):
    ''' omap - map OCI resources collected in .ocids file '''

    # Sloppy.  I know.
    global ocid, ocids, wrap
    global compartments_only, instances, vcns, maxdepth, use_bold, long

    # ==========================================================================

    def omap_show_item_names(prefix, resourcetype, items):
        suffix = '' if len(items) == 1 else 's'
        itemstr = ', '.join([i['alias'] for i in items])
        itemstr = re.sub(r' \(Boot Volume\)', '', itemstr)
        itemstr = re.sub(r': ocid[^ ,]{73}', '...', itemstr)
        print(textwrap.fill(bold(str(len(items)) + ' ' + resourcetype + suffix + ': ') + itemstr,
              initial_indent=' ' * len(prefix),
              subsequent_indent='        ' + ' ' * len(prefix),
              break_on_hyphens=False,
              break_long_words=True,
              width=wrap))

    # ==========================================================================

    def omap_show_items(prefix, resourcetype, items):
        """Show each field in list, align columns based on max widths."""
        for i in items:
            i['alias'] = re.sub(r' \(Boot Volume\)', '', i['alias'])
            if 'score' in i:
                del i['score']
            if 'parents' in i:
                del i['parents']

        # get column widths for every field in every item
        column = {}
        for i in items:
            for k in i.keys():
                if k not in column:
                    if k == 'availability-domain':
                        column[k] = {'head': 'AD', 'maxwidth': 2, 'width': 2, 'format': '{:>2}'}
                    else:
                        maxwidth = max([len(str(f[k])) for f in items if k in f])
                        maxwidth = max(maxwidth, len(k))
                        if k.endswith('id'):
                            width = 8
                        else:
                            width = min(maxwidth, 30)
                        column[k] = {'head': k, 'maxwidth': maxwidth, 'width': width,
                                     'format': '{:' + str(width) + '.' + str(width) + '}'}

        # shorten long column headings
        for k in column.keys():
            column[k]['head'] = re.sub('default-', 'd-', column[k]['head'])
        for k in column.keys():
            if column[k]['head'].startswith('size-in-'):
                column[k]['head'] = column[k]['head'][8:]
                if column[k]['head'] == 'gbs':
                    column[k]['format'] = '{:>3.3}'
                else:
                    column[k]['format'] = '{:>8.8}'
        column['alias']['head'] = 'name'

        suffix = '' if len(items) == 1 else 's'
        print(prefix + bold(str(len(items)) + ' ' + resourcetype + suffix + ': '))
        header = []
        hide_these_columns = ['type', 'name', 'display-name']

        for k in column.keys():
            if k not in hide_these_columns:
                header.append(column[k]['format'].format(column[k]['head']))

        # show each item
        print(prefix + bold(' '.join(header)))
        for i in items:
            print(prefix, end='')
            for k in column.keys():
                if k in i and k not in hide_these_columns:
                    # right-truncate ocids
                    if long == 1 and k.endswith('id'):
                        print(column[k]['format'].format(i[k][-8:]), end=' ')
                    elif k == 'availability-domain':
                        print(column[k]['format'].format(str(i[k])[-1:]), end=' ')
                    else:
                        print(column[k]['format'].format(str(i[k])[:column[k]['maxwidth']]),
                              end=' ')
            print('')
        print('')
        return

    # ==========================================================================

    def omap_show_compartment(this, depth=0):
        """Show the resources in this compartment and children up to maxdepth.
        """

        indent = ''  # ' ' * (depth*4)

        # list everything in this compartment that is not DELETED
        stuff = [i for i in ocids
                 if ('compartment-id' in i and i['compartment-id'] == this['id']
                     and (('lifecycle-state' not in i)
                          or ('lifecycle-state' in i and i['lifecycle-state'] != 'DELETED')))]
        types = sorted(list(set([i['type'] for i in stuff])))

        subcompartments = [i for i in stuff if i['type'] == 'compartment']

        if long and subcompartments:
            print('\n' + indent + bold(this['type'].upper() + ' ' + this['alias']))
        else:
            # print(bold(indent + this['alias']), end='')
            if compartments_only:
                print(indent + this['alias'])
            else:
                print(bold(indent + this['alias']))

        if vcns:
            vcnlist = [i for i in stuff if i['type'] == 'vcn']
            for vcn in vcnlist:
                vcnstuff = [i for i in ocids if 'vcn-id' in i and i['vcn-id'] == vcn['id']]
                print('VCN:', vcn['alias'])
                for i in vcnstuff:
                    if i['type'] not in ['subnet', 'securitylist']:
                        print('    {:25}'.format(i['type'] + ':'), i['alias'])
                for subnet in [i for i in vcnstuff if i['type'] == 'subnet']:
                    print('\n    SUBNET', '{:18}'.format(subnet['alias']), subnet['cidr-block'])
                    # get vnics and vnicattachments
                    vnics = [i for i in ocids if i['type'] == 'vnic'
                             and i['subnet-id'] == subnet['id']]
                    for vnic in vnics:
                        print('      vnic',
                              '{:18}'.format(vnic['alias']),
                              '{:18}'.format(vnic['private-ip'] if 'private-ip' in vnic else ''),
                              ('{:16}'.format(vnic['public-ip'] if 'public-ip' in vnic else '')),
                              end='')
                        vnicattachments = [i for i in stuff
                               if (i['type'] == 'vnicattachment'  # noqa: E128
                                   and i['vnic-id'] == vnic['id']
                                   and i['lifecycle-state'] == 'ATTACHED')]

                        # The vnicattachment name often is the same as the
                        # instance name.  But if either has been renamed,
                        # it's good to be able to connect the two.
                        for va in vnicattachments:
                            print('  inst:', ocid[va['instance-id']]['alias'], end='')
                        print('')
                    lbs = [i for i in ocids if i['type'] == 'loadbalancer'
                           and subnet['id'] in i['subnet-ids']]
                    for lb in lbs:
                        print('      ' + '{:21}'.format(lb['type']), '{:28}'.format(lb['alias']),
                              ', '.join([ip['ip-address'] for ip in lb['ip-addresses']]))
                    try:
                        print('      securitylists:',
                              ', '.join([ocid[sl]['alias'] for sl in subnet['security-list-ids']]))
                    except BaseException:
                        pass
                print('')
        else:
            for type in types:
                if ((not compartments_only and not instances)
                        or (compartments_only and type == 'compartment')
                        or (instances and type == 'instance')):
                    tstuff = [i for i in stuff if i['type'] == type]
                    if long:
                        omap_show_items(indent, type, tstuff)
                    elif not compartments_only:
                        omap_show_item_names(indent, type, tstuff)

        subcompartments = [i for i in stuff if i['type'] == 'compartment']
        if not compartments_only and stuff:
            print('')
        for c in subcompartments:
            c['alias'] = this['alias'] + '/' + c['alias']
            if (depth < maxdepth):
                omap_show_compartment(c, depth + 1)

    # ==========================================================================

    def omap_usage(s=''):
        print("""
    omap - Map the tenancy details in your .ocids (experimental)

    usage: o map [-c] [-d depth] [-ilvn] [-w <n>] [ <compartment> | help ]

               -c            compartments list
               -i            Instance centric view
               -v            VCN centric view
               -l            long listing - show more resource details
               -n            no highlighting (bold off)
               -d <depth>    show children <depth> levels down
               -w <n>        wrap long lines at <n> characters
               <compartment> starting point for map

    """)
        if s != '':
            print(bold(s) + '\n')
        exit(1)

    # ==========================================================================
    # start of omap()
    # ==========================================================================

    try:
        optvals, otherparams = getopt.getopt(argv, 'cd:ilnvw:')
    except getopt.error as err:
        omap_usage(str(err))

    opts = [o for o, v in optvals]
    if len(otherparams) == 0 or 'help' in otherparams:
        omap_usage('')
    if len(otherparams) > 1:
        omap_usage('too many arguments: ' + ' '.join(otherparams))

    compartments_only = '-c' in opts
    instances = '-i' in opts
    vcns = '-v' in opts
    maxdepth = 6
    if '-d' in opts:
        maxdepth = [int(v) for o, v in optvals if o == '-d'][0]
    use_bold = '-n' not in opts
    long = len([o for o in opts if '-l' == o])
    if '-w' in opts:
        wrap = int([int(v) for o, v in optvals if o == '-w'][0])
    start_param = otherparams[0]

    ocids_file('read')

    # Find starting point(s) - could be one or more matching compartments.
    map_start = value_parameter('--compartment-id', start_param)
    omap_show_compartment(ocid[map_start])
    exit(0)

# ==============================================================================


def prune(argv):
    ''' o prune - remove a branch from the .ocids stored values'''

    global ocid, ocids, go

    # ==========================================================================

    def prune_this(item):
        n = 0
        print("pruning",
              re.sub(r'\.[a-z0-9]*$', '...', item['id']) + item['id'][-8:],
              item['lifecycle-state'] if 'lifecycle-state' in item else '',
              '/'.join(item['parents']) if 'parents' in item else '')
        stuff = []
        if item['type'] == 'vcn':
            stuff = [i for i in ocids if ('vcn-id' in i and i['vcn-id'] == item['id'])]
        elif item['type'] == 'compartment':
            stuff = [i for i in ocids if ('compartment-id' in i
                                          and i['compartment-id'] == item['id'])]

        for i in stuff:
            n += prune_this(i)
        if item['id'] in ocid:
            del ocid[item['id']]
        return n + 1

    # ==========================================================================
    # start of prune()
    # ==========================================================================

    if len(argv) == 0:
        usage('help')
        exit(0)
    if argv[-1] in ('go', '!', '.'):
        go = True
        argv.pop(-1)

    ocids_file('read')
    num_ocids = len(ocids)

    pruned = 0
    for arg in argv:
        # if arg matches one ocid, remove that entry
        # if multiple matches, look for vcn first, then compartment

        if arg in ['DELETED', 'TERMINATED', 'INACTIVE', 'DETACHED']:
            m = [item for k, item in ocid.items()
                 if 'lifecycle-state' in item and item['lifecycle-state'] == arg]
            for i in m:
                pruned += prune_this(i)
        else:
            m = sorted([item for k, item in ocid.items() if alias_match(
                arg, item)], key=lambda i: i['score'], reverse=True)
            if len(m) == 0:
                print(arg + ': no match')
            elif len(m) < 10:
                for i in m:
                    pruned += prune_this(i)
            else:
                vcn = [i for i in m if i['type'] == 'vcn']
                if vcn:
                    pruned += prune_this(vcn[0])
                else:
                    c = [i for i in m if i['type'] == 'compartment']
                    if c:
                        pruned += prune_this(c[0])
                    else:
                        print(arg + ': ambiguous - ', len(m), 'matches')

    item = 'item' if pruned == 1 else 'items'
    if not go:
        print(bold('Use "go" to prune ' + str(pruned) + '  ' + item + ' from ' + ocids_file_name))
    elif pruned > 0:
        ocids_file('write', {})
        print('Pruned', pruned, 'of', num_ocids, 'OCIDs. ', len(ocid), 'OCIDs remain in ',
              ocids_file_name)
    exit(0)

# ==============================================================================


def ocid_lookup(argv):
    '''Lookup resource names or ocids'''

    ocids_file('read')

    for arg in argv:
        m = sorted([item for k, item in ocid.items() if alias_match(arg, item)],
                   key=lambda i: i['score'], reverse=True)
        if len(m) == 0:
            print(arg + ': no match', file=sys.stderr)
        else:
            width = max(len(i['id']) for i in m)
            for item in m:
                s = ''
                if sys.argv[1] == 'ocids' and 'parents' in item:
                    s = '/'.join(item['parents'])
                print(('{:' + str(width) + '}').format(item['id']), s)
    exit(0)

# ==============================================================================


def get_oci_commands(argv):
    ''' o oci_commands - extract commands and parameters from oci --help '''

    def oci_command_out(cmd, eol=''):
        f.write(cmd + '\n')
        cmd = re.sub(r' [+-].*', '', cmd)
        print('\033[2K\r       ', cmd, end=eol, flush=True)

    def clean_up_param(s):
        # example in:  -c, --compartment-id TEXT
        #         out: --compartment-id [text]
        # print(s)
        param = re.sub(r' [A-Z[].*', '', s)
        type = s[len(param) + 1:]
        if type and not type.startswith('['):
            type = '[' + type.lower() + ']'
        longest_param = max(param.split(', '), key=len).strip()
        if longest_param != '--help':
            return longest_param + (' ' + type if type else '')

    oci_dir = os.path.expanduser('~/.oci')
    oci_commands_file = os.path.expanduser('~/.oci/oci_commands')

    # o oci_commands - no service name; get commands for all services
    if len(sys.argv) == 2:
        sp = subprocess.run(['oci', '--help'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out = sp.stdout.decode('utf-8')
        part1 = re.sub(r'.*Options:\n|Commands:\n.*', '', out, flags=re.S)
        globals = sorted(list(dict.fromkeys(re.findall(r'--[A-Za-z-]*', part1))))
        if not os.path.exists(oci_dir):
            os.mkdir(oci_dir, mode=0o755)
        print("Creating", bold(oci_commands_file))
        f = open(oci_commands_file, 'w')
        f.write('global_options ' + ' '.join(globals) + '\n')
        f.close()

        part2 = re.sub(r'.*Commands:\n', '', out, flags=re.S)
        r = re.compile("  [a-z]")
        services = [re.sub('^  |  .*$', '', s)
                    for s in list(set(filter(r.match, part2.splitlines())))]
        services.sort()
        for n, service in enumerate(services, start=1):
            print('\033[2K\r({}/{}) Getting {} commands...'.format(
                  n, len(services), service) + 30 * ' ')
            subprocess.run([sys.argv[0], 'oci_commands', service])
        print('\033[2K\rDone.')
        exit(0)

    # o oci_commands <service>
    sp = subprocess.run(['oci'] + sys.argv[2:] + ['--help'],
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out = sp.stdout.decode('utf-8')

    if out.startswith('Usage'):
        # Click help instead of man page...
        # Recurse through Commands to get usage for each command individually.
        # Warn user that this is the slow method
        if sys.argv[2] == 'raw-request':
            print(bold("""
    The oci-cli on this system does not include preformatted help.
    This means that it'll take up to an hour to collect usage for all
    commands and save to {}
""".format(os.path.expanduser('~/.oci/oci_commands'))))

        if re.search(r'\nCommands:\n', out, flags=re.M):
            commands = re.sub(r'.*\nCommands:\n', '', out, flags=re.S)
            for line in commands.splitlines():
                if re.match(r'^  [a-z0-9-]+', line):
                    cmd = line.strip().split(' ')[0]
                    subprocess.run([sys.argv[0], 'oci_commands'] + sys.argv[2:] + [cmd])
            print('\033[2K\r', end='')
            exit(0)

        # Parse usage for individual command from click help
        m = re.search(r'Usage: (.*?) \[.*]', out, re.S)
        if m:
            cmd = re.sub(r'[ \n]+', ' ', m.group(1)).strip()
        param = ''
        required = []
        optional = []
        for ln in re.sub(r'.*\nOptions:\n', '', out, flags=re.S).splitlines():
            m = re.match(r'  (-.*?)(  |$)', ln)
            if m:
                if param:
                    optional.append(param)
                param = clean_up_param(m.group(1))
            if param and '[required]' in ln:
                required.append(param)
                param = ''
        if param:
            optional.append(param)

        if required:
            cmd += ' ' + ' '.join(sorted(required))
        if optional:
            cmd += ' + ' + ' '.join(sorted(optional))
        f = open(oci_commands_file, 'a')
        oci_command_out(cmd)
        f.close()
        exit(0)

    # Parse usage for multiple commands from man page help
    # Remove bold
    lines = re.sub(r'(\x08.|\x1B...)', '', out).splitlines()

    f = open(oci_commands_file, 'a')
    cmd = ''
    for n, line in enumerate(lines):
        # Look for start of new command
        # Single command man page has: ^USAGE
        # Multi-command man page has:  ^   Usage
        if re.match('^(USAGE|   Usage)', line):
            # if previous command in buffer, save it
            if cmd:
                oci_command_out(cmd)
            cmd = re.sub(' .OPTIONS.', '', lines[n + 1]).strip()

        # look for parameter specification
        elif re.search(r'^ {6,7}-[a-z0-9\-,]+($|.* \[.+])', line):
            cmd = cmd + ' ' + clean_up_param(line.strip())

        elif re.search(r'optional parameters', line, re.I):
            cmd = cmd + ' +'

        # elif re.search('Accepted values are:', line):
        elif line.endswith('Accepted values are:'):
            s = re.sub(r', ', r'|', lines[n + 2].strip())
            cmd = cmd[:-5] + s + ']'

    oci_command_out(cmd, eol='\033[2K\r')
    f.close()
    exit(0)


# ==============================================================================
# MAIN PROGRAM STARTS HERE - choose map, prune, ocids, oci_commands or "o" main
# ==============================================================================
signal.signal(signal.SIGINT, interrupted)
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

if len(sys.argv) > 1 and sys.argv[1] == 'map':
    omap(sys.argv[2:])

elif len(sys.argv) > 1 and sys.argv[1] == 'prune':
    prune(sys.argv[2:])

elif len(sys.argv) > 1 and sys.argv[1] == 'oci_commands':
    get_oci_commands(sys.argv[1:])

elif len(sys.argv) > 1 and sys.argv[1] in ('ocid', 'ocids'):
    ocid_lookup(sys.argv[2:])

# The above functions do not return, but exit on completion.
# If we got this far we're in o main.

command = read_oci_commands_file()
ocids_file('read')

# ==============================================================================
# Process 'o' options: -o 'output keys' ...  help go
# ==============================================================================
try:
    optvals, CLI_params = getopt.getopt(sys.argv[1:], 'Oo:Qqw:')
except getopt.error as err:
    usage(str(err))

opts = [o for o, v in optvals]
quiet = '-q' in opts
Quiet = '-Q' in opts
if '-w' in opts:
    wrap = int([int(v) for o, v in optvals if o == '-w'][0])
if '-O' in opts:
    ocids_in_output = True
if '-o' in opts:
    user_out_spec = [v for o, v in optvals if o == '-o'][0]
    if user_out_spec in ['json', 'JSON']:
        user_out_spec = ''
    elif user_out_spec in ['text', 'raw']:
        user_out_spec = '/'
else:
    user_out_spec = default_out_spec

if len(CLI_params) == 0:
    usage()

if CLI_params[-1] in ('go', '!', '.'):
    go = True
    if CLI_params[-1] == '!':
        go = 2
    CLI_params.pop(-1)
elif CLI_params[-1].endswith('!') or CLI_params[-1].endswith('.'):
    go = True
    if CLI_params[-1].endswith('!'):
        go = 2
    CLI_params[-1] = CLI_params[-1][:-1]
elif 'help' == CLI_params[-1]:
    if len(CLI_params) == 1:
        usage('help')
    show_help = True
    CLI_params.pop(-1)


# ==============================================================================
# Identify matching oci cli command(s)
# ==============================================================================
options_in_args = any(len(i) > 0 and '-' in i[0] for i in CLI_params)

# Prioritize core services above others.  The list could include: os, fs, bv
# But these already have priority due to their short service names.
# Each service name must end with ' '.
priority_services = ('compute ', 'bv ', 'os ', 'network ', 'iam ')

# Find matching commands.  Sort by priority, then by command length.
matches = sorted([c for c in command if args_match_command(c, CLI_params)],
                 key=lambda c: (not c['action'].startswith(priority_services),
                 len(c['action'])), reverse=True)
best_match = len(matches) - 1

# ==============================================================================
# Take action - either show help or 'go' run the command
# ==============================================================================
if len(matches) == 0:
    usage('no matching command found: ' + ' '.join(CLI_params)
          + '\n\nTry:  o .')

# If many matches, list matches and exit
elif len(matches) > 16:
    print(bold('Possible commands:'))
    for c in matches:
        show_command(c, prefix='    ')
    print('use:', bold('o <command>'), 'for options')
    exit(0)

# Fewer than 16 matches - if options provided, try the shortest command
elif show_help:
    for c in matches:
        show_command(c, full=True)
    print('use:', bold('o ' + c['action'] + ' --help go'), 'for full oci help')
    exit(0)

# Fewer than 16 matches. Didn't ask for help.
elif not go and not Quiet:
    if len(matches) > 1:
        if options_in_args:
            print(bold(str(len(matches)) + ' other matching commands not shown.'
                  + ' (Remove parameters to see other commands.)'), end='')
        else:
            print(bold('Possible matches:'))
            for i in range(len(matches)):
                if i != best_match:
                    show_command(matches[i], prefix='    ')
        print(bold('\nBest match:'))
    show_command(matches[best_match], full=True)

# ==============================================================================
# We've settled on matching_command[best_match].
# Continue interpreting additional parameters (even if no 'go')
# ==============================================================================
c = matches[best_match]
oci_command_line = 'oci ' + c['action']

if c['action'] in ('audit event list', 'logging-search search-logs') and \
        user_out_spec == default_out_spec:
    user_out_spec = ''

all_options_for_this_cmd = c['required'] + ' ' + c['optional'] + ' ' + global_options + ' '
remaining_options = all_options_for_this_cmd
while CLI_params and CLI_params[0][0] != '-':
    CLI_params.pop(0)

# Determine the target region for this command, so that we can filter
# ocids by region.  See if region or profile is on command line...
for i in range(len(CLI_params)):
    a = CLI_params[i]
    if len(a) == 0 or not a.startswith('-'):
        continue
    if option_parameter(a) == '--region':
        oci_command_line += ' --region ' + CLI_params[i + 1]
        break
    if option_parameter(a) == '--profile':
        oci_command_line += '--profile ' + CLI_params[i + 1]
region_code, region = get_region()

# Interpret remaining command line arguments based on command:
rn = None
last_option = ''
for a in CLI_params:
    if len(a) == 0:
        continue
    if a.startswith('-'):
        options_out.append(option_parameter(a))
        last_option = options_out[-1]
        # don't match the same parameter more than once
        remaining_options = re.sub(last_option + ' '
                                   + r'(\[[A-Za-z0-9-_|\]]* )',
                                   '', remaining_options)
    else:
        if last_option == '--region':
            rn = len(options_out)
        options_out.append(value_parameter(last_option, a))

# if orphans found while processing parameters, remove them from ocids file
if orphans:
    ocids_file('write')

for o in options_out:
    if o.startswith('-') and o != '-':
        oci_command_line += '\\\n   '
    oci_command_line += shell_escape(o) + ' '

# if region is different from what was on command line, fix command line
if rn and region and options_out[rn] != region:
    oci_command_line = re.sub('--region ' + options_out[rn],
                              '--region ' + region, oci_command_line)
    options_out[rn] = region

# ==============================================================================
# Display the full oci cli command with expanded options
# ==============================================================================
if not go and len(options_out) == 0:
    exit(0)

if not quiet:
    print('\n' + oci_command_line + '\n', file=sys.stderr)

# ToDo:  This doesn't address cli interactive input
#        e.g. confirming deletes.
if '--force' in c['optional'] and '--force' not in options_out:
    print(bold('Use --force to take action without prompts.'))
    if go:
        print(bold('If the command seems stuck, it may be waiting for a '
              + '"yes" confirmation.'))

if nogo and go != 2:
    exit(1)
if not go:
    exit(0)

# ==============================================================================
# Execute the oci cli command (finally!)
# ==============================================================================
try:
    if sys.version_info[1] > 6:
        # capture_output option requires 3.7+
        cli = subprocess.run(['oci'] + c['action'].split(' ') + options_out, capture_output=True)
    else:
        cli = subprocess.run(['oci'] + c['action'].split(' ') + options_out,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
except subprocess.SubprocessError as err:
    print('ERROR:', err)

try:
    stdout_str = cli.stdout.decode('utf-8')
except UnicodeDecodeError:
    sys.stdout.buffer.write(cli.stdout)
    exit(0)

if cli.returncode > 0 or cli.stdout is None \
        or cli.stdout.decode('utf-8') == '':
    if cli.stdout is not None and cli.stdout:
        print(cli.stdout.decode('utf-8'))
    if cli.stderr is not None and cli.stderr:
        error_out(cli.stderr.decode('utf-8'))
    exit(cli.returncode)

# Interpret output as JSON
try:
    jsonOut = json.loads(cli.stdout.decode('utf-8'))
except ValueError:
    # json.loads failed, show us what you got
    if cli.stdout is not None:
        print(cli.stdout.decode('utf-8'))
    if cli.stderr is not None:
        error_out(cli.stderr.decode('utf-8'))
    exit(1)

if type(jsonOut) is dict and 'data' in jsonOut:
    # Possible JSON 'data' returns:
    #   get:   {'data': {'compartment-id': 'ocid1.compartment.oc1..aaa...
    #   list:  {'data': [{'compartment-id': 'ocid1.compartment.oc1..aaid7...
    #   ns get:  { "data": "mytenancyname" }
    #   service-connector list:  {'data': { 'items': [ ]}}
    # copy the returned 'data' into results list
    if type(jsonOut['data']) is list:
        results = jsonOut['data']
    elif type(jsonOut['data']) is dict:
        if 'items' in jsonOut['data'] and type(jsonOut['data']['items']) is list:
            results = jsonOut['data']['items']
        else:
            results = [jsonOut['data']]
    else:
        results = [jsonOut]  # sloppy

elif type(jsonOut) is list and type(jsonOut[0]) is dict:
    # Other JSON outputs:
    # --query extracts results from 'data' into various structures.
    # -gfcji: { "messages": [ { "key": "string", "value": "string" },
    #    or   {'agentConfig': {'isMonitoringDisabled': True}, 'definedTags...
    # I may be able to format the output, but don't try to save this data.
    results = jsonOut

else:
    # It's JSON, but I don't understand its format.
    print(cli.stdout.decode('utf-8'))
    exit(cli.returncode)

# Try to preserve access-uri from existing record
for item in results:
    if 'access-uri' in item:
        item['access-uri'] = 'https://objectstorage.' + region\
            + '.oraclecloud.com' + item['access-uri']
    elif ('object-name' in item and 'id' in item and item['id'] in ocid
            and 'access-uri' in ocid[item['id']]):
        item['access-uri'] = ocid[item['id']]['access-uri']

if not user_out_spec:
    # no "-o fields" specified, show json output from CLI
    print(cli.stdout.decode('utf-8'))

else:
    # Identify output fields from user -o spec, format for each field
    # Get max width of each field - or format with user spec
    out_fields, out_sep = \
        get_fields_from(user_out_spec, list(set([k for i in results for k in i.keys()])))
    if out_fields:
        set_column_widths(out_fields, results)
        # Then output header and requested fields from item_list
        show_column_headers(out_fields, out_sep)
        for item in results:
            show_item(item, out_fields, out_sep)

# report stderr from oci cli, if any, AFTER results
if cli.stderr is not None and len(cli.stderr):
    error_out(cli.stderr.decode('utf-8'))

if type(jsonOut) is dict and 'data' in jsonOut:
    newids = get_new_ocids_from_returned_items(results)
    if not newids.items() < ocid.items():
        ocids_file('write', newids)

exit(cli.returncode)
# ==============================================================================
# End of o main program
# ==============================================================================
